React Hooks Cheat Sheet
useState
Purpose: Adds state to functional components
Syntax: const [state, setState] = useState(initialValue);

Key Points:

Returns current state value and setter function

Use functional updates when new state depends on previous state

Always spread previous state when updating objects/arrays

Lazy initialization for expensive computations

When to use: Managing component data that changes over time

useEffect
Purpose: Handles side effects in functional components
Syntax: useEffect(() => { effect }, [dependencies]);

Three Patterns:

Run once (on mount): useEffect(() => {}, []);

Run on dependency change: useEffect(() => {}, [dep1, dep2]);

Run after every render: useEffect(() => {});

Key Points:

Return cleanup function for subscriptions/timeouts/event listeners

Empty dependency array = run only once

Missing dependencies can cause bugs

Don't put state setters for the same state in effect dependencies

When to use: API calls, subscriptions, event listeners, timers

useMemo
Purpose: Memoizes expensive calculations
Syntax: const memoizedValue = useMemo(() => compute(a, b), [a, b]);

Key Points:

Only recalculates when dependencies change

Improves performance by avoiding unnecessary recalculations

Don't overuse - has its own cost

Not for side effects

When to use: Heavy computations, filtering large arrays, derived data

useCallback
Purpose: Memoizes function references
Syntax: const memoizedFn = useCallback(() => { doSomething(a, b) }, [a, b]);

Key Points:

Returns same function reference until dependencies change

Prevents unnecessary re-renders of child components

Only use when you have proven performance issues

When to use: Passing callbacks to optimized child components

useRef
Purpose: Creates mutable references that persist across renders
Syntax: const ref = useRef(initialValue);

Two Main Uses:

Accessing DOM elements: ref={myRef}

Storing mutable values: ref.current = value

Key Points:

Changing .current doesn't trigger re-renders

Great for accessing DOM elements directly

Useful for keeping previous values, timeouts, intervals

When to use: DOM manipulation, storing values that don't affect UI

Rules of Hooks
Only call hooks at the top level (not in loops/conditions)

Only call hooks from React function components

Use ESLint plugin to enforce rules

Performance Tips
Use React.memo() for component memoization

Use useMemo/useCallback only when needed

Split components to isolate expensive operations

Virtualize long lists

Common Pitfalls
Stale closures in useEffect/timeouts/intervals

Solution: Use functional updates for state

Infinite loops in useEffect

Solution: Check dependency arrays

Missing dependencies in useEffect/useMemo/useCallback

Solution: Add all referenced values to dependency array

Over-optimization with useMemo/useCallback

Solution: Only optimize proven bottlenecks

Quick Reference
Hook	Purpose	Triggers Re-render
useState	Manage state	✅ Yes
useEffect	Side effects	❌ No
useMemo	Memoize values	❌ No
useCallback	Memoize functions	❌ No
useRef	Store references	❌ No
Save this file as react-hooks-cheatsheet.txt for quick reference!

New chat
